// filter.lib - digital filters of various types useful in audio and beyond

declare name "Faust Filter Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.19";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "https://ccrma.stanford.edu/~jos/filters/";

import("music.lib"); // delay, frac and, from math.lib, SR and PI

//---------------------- zero(z) --------------------------
// z = location of zero along real axis in z-plane
// Difference equation: y(n) = x(n) - z * x(n-1)
// Reference: https://ccrma.stanford.edu/~jos/filters/One_Zero.html

zero(z) =  _ <: _,mem : _,*(z) : -;

//------------------------ pole(p) ---------------------------
// p = pole location = feedback coefficient
// Could also be called a "leaky integrator".
// Difference equation: y(n) = x(n) + p * y(n-1)
// Reference: https://ccrma.stanford.edu/~jos/filters/One_Pole.html

pole(p) = + ~ *(p);

//---------------------- integrator --------------------------
// pole(1) [implemented separately for block-diagram clarity]

integrator = + ~ _ ;

//----------------------- tau2pole ---------------------------
// tau2pole(tau) returns a real pole giving exponential decay with
// tau = time-constant in seconds
//
tau2pole(tau) = exp(-1.0/(tau*SR));

//---------------------- smooth(s) --------------------------
// Exponential smoothing by a unity-dc-gain one-pole lowpass
//
// USAGE: smooth(tau2pole(tau)), where 
//   tau = desired smoothing time constant in seconds,
// or
//   smooth(s), where s = smoothness between 0 and 1.
//    s=0 for no smoothing
//    s=0.999 is "very smooth"
// s>1 is unstable, and s=1 yields the zero signal for all inputs.
// The exponential time-constant is approximately 
// 1/(1-s) samples, when s is close to (but less than) 1.
// Reference: 
// https://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html

smooth(s) = *(1.0 - s) : + ~ *(s);

//------------------- dcblockerat(fb) -----------------------
// fb = "break frequency" in Hz, i.e., -3 dB gain frequency.
// The amplitude response is substantially flat above fb,
// and sloped at about +6 dB/octave below fb.
// Derived from the analog transfer function 
// H(s) = s / (s + 2*PI*fb) 
// by the low-frequency-matching bilinear transform method
// (i.e., the standard frequency-scaling constant 2*SR).
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html

dcblockerat(fb) = *(b0) : zero(1) : pole(p)
with {
  wn = PI*fb/SR;
  b0 = 1.0 / (1 + wn);
  p = (1 - wn) * b0;
};

//---------------------- dcblocker --------------------------
// Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz)
// and high-frequency gain near 1.0025 (due to no scaling)
//
dcblocker = zero(1) : pole(0.995);

//------------ notchw(width,freq), notch(freq) --------------
// width = "notch width" in Hz (approximate)
// freq  = "notch frequency" in Hz
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Phasing_2nd_Order_Allpass_Filters.html

notchw(width,freq) = tf2(b0,b1,b2,a1,a2)
with {
  fb = 0.5*width; // First design a dcblockerat(width/2)
  wn = PI*fb/SR;
  b0db = 1.0 / (1 + wn);
  p = (1 - wn) * b0db; // This is our pole radius.
  // Now place unit-circle zeros at desired angles:
  tn = 2*PI*freq/SR;
  a2 = p * p;
  a2p1 = 1+a2;
  a1 = -a2p1*cos(tn);
  b1 = a1;
  b0 = 0.5*a2p1;
  b2 = b0;
};

//========================= Comb Filters ===============================

//------------------------- ffcombfilter ---------------------------
// Feed-Forward Comb Filter
// 
// USAGE: ffcombfilter(maxdel,del,g), where
//   maxdel = maximum delay (a power of 2)
//   del = current comb-filter delay between 0 and maxdel
//   g = gain applied to delay-line output
//
// Reference: 
//   https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html

ffcombfilter(maxdel,del,g) = _ <: _,(delay(maxdel,del) : *(g)) : + ;

//------------------- fbcombfilter, ffbcombfilter -------------------
// Feed-Back Comb Filter
//
// USAGE: fbcombfilter(maxdel,intdel,g), where
//   maxdel = maximum delay (a power of 2)
//   intdel = current comb-filter delay between 0 and maxdel
//   g = gain applied to delay-line output = feedback gain
//
// or, if fractional delay is needed,
//   ffbcombfilter(maxdel,del,g), where del is (non-int) delay
//
// Reference: 
//   https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html

fbcombfilter(maxdel,intdel,g) = (+ : delay(maxdel,intdel)) ~ *(g);
ffbcombfilter(maxdel,del,g) = (+ : fdelay(maxdel,del)) ~ *(g);

//================ Second Order Digital Filter Sections ================

// Specified by transfer-function polynomials B(z)/A(z) as in matlab

//----------------------------- tf1 ---------------------------------
// First-order direct-form digital filter

tf1(b0,b1,a1) = _ <: *(b0), (mem : *(b1)) :> + ~ *(0-a1);

//----------------------------- tf2 ---------------------------------
// Second-order direct-form digital filter.
// This is just a copy of TF2(b0,b1,b2,a1,a2) from Faust's music.lib.

tf2(b0,b1,b2,a1,a2) = sub ~ conv2(a1,a2) : conv3(b0,b1,b2)
with {
  conv3(k0,k1,k2,x)     = k0*x + k1*x' + k2*x'';
  conv2(k0,k1,x)        = k0*x + k1*x';
  sub(x,y)              = y-x;
};

//----------------------------- tf3 ---------------------------------
// Third-order direct-form digital filter

tf3(b0,b1,b2,b3,a1,a2,a3) = sub ~ conv3(a1,a2,a3) : conv4(b0,b1,b2,b3)
with {
  conv3(k0,k1,k2,x)     = k0*x + k1*x' + k2*x'';
  conv4(k0,k1,k2,k3,x)  = k0*x + k1*x' + k2*x'' + k3*x''';
  sub(x,y)              = y-x;
};

//----------------------------- tf4 ---------------------------------
// Fourth-order direct-form digital filter

tf4(b0,b1,b2,b3,b4,a1,a2,a3,a4) = sub ~ conv4(a1,a2,a3,a4) 
                                      : conv5(b0,b1,b2,b3,b4)
with {
  conv4(k0,k1,k2,k3,x)    = k0*x + k1*x' + k2*x'' + k3*x''';
  conv5(k0,k1,k2,k3,k4,x) = k0*x + k1*x' + k2*x'' + k3*x''' + k4*x'''';
  sub(x,y)                = y-x;
};

//----------------------------- wgr ---------------------------------
// Second-order transformer-normalized digital waveguide resonator
// USAGE: wgr(f,r), where
//   f : resonance frequency (Hz)
//   r : loss factor for exponential decay 
//        (set to 1 to make a numerically stable oscillator)
//
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html
//
wgr(f,r,x) = (*(G),_<:_,((+:*(C))<:_,_),_:+,_,_:+(x),-) ~ cross : _,*(0-gi)
with { 
  C = cos(2*PI*f/SR);
  gi = sqrt((1+C)/(1-C)); // compensate amplitude (only needed when 
  G = r*(1-1' + gi')/gi;  //   frequency changes substantially)
  cross = _,_ <: !,_,_,!;
};

//----------------------------- nlf2 --------------------------------
// Second order normalized digital waveguide resonator
// USAGE: nlf2(f,r), where
//   f : resonance frequency (Hz)
//   r : loss factor for exponential decay 
//        (set to 1 to make a sinusoidal oscillator)
//
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html
//
nlf2(f,r,x) = ((_<:_,_),(_<:_,_) : (*(s),*(c),*(c),*(0-s)) :> 
              (*(r),+(x))) ~ cross
with { 
  th = 2*PI*f/SR;
  c = cos(th);
  s = sin(th);
  cross = _,_ <: !,_,_,!;
};

//===== Digital Filter Sections Specified as Analog Filter Sections =====
//
//----------------------------- tf2s --------------------------------
// Second-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.  Digitization via the
// bilinear transform is built in.
//
// USAGE: tf2s(b2,b1,b0,a1,a0,w1), where 
//
//         b2 s^2 + b1 s + b0
// H(s) = --------------------
//            s^2 + a1 s + a0
//
// and w1 is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., s = j).
//
// EXAMPLE: A second-order ANALOG Butterworth lowpass filter,
//          normalized to have cutoff frequency at 1 rad/sec,
//          has transfer function
//
//              1
// H(s) = -----------------
//         s^2 + a1 s + 1
//
// where a1 = sqrt(2).  Therefore, a DIGITAL Butterworth lowpass 
// cutting off at SR/4 is specified as tf2s(0,0,1,sqrt(2),1,PI*SR/2);
//
// METHOD: Bilinear transform scaled for exact mapping of w1.
// REFERENCE: 
//   https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html
//
tf2s(b2,b1,b0,a1,a0,w1) = tf2(b0d,b1d,b2d,a1d,a2d)
with {
  c   = 1/tan((w1)*0.5/SR); // bilinear-transform scale-factor
  csq = c*c;
  d   = a0 + a1 * c + csq;
  b0d = (b0 + b1 * c + b2 * csq)/d;
  b1d = 2 * (b0 - b2 * csq)/d;
  b2d = (b0 - b1 * c + b2 * csq)/d;
  a1d = 2 * (a0 - csq)/d;
  a2d = (a0 - a1*c + csq)/d;
};

//----------------------------- tf1s --------------------------------
// First-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.
//
// USAGE: tf1s(b1,b0,a0,w1), where 
//
//        b1 s + b0
// H(s) = ----------
//           s + a0
//
// and w1 is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., s = j).
//
// EXAMPLE: A first-order ANALOG Butterworth lowpass filter,
//          normalized to have cutoff frequency at 1 rad/sec,
//          has transfer function
//
//           1
// H(s) = -------
//         s + 1
//
// so b0 = a0 = 1 and b1 = 0.  Therefore, a DIGITAL first-order 
// Butterworth lowpass with gain -3dB at SR/4 is specified as 
//
// tf1s(0,1,1,PI*SR/2); // digital half-band order 1 Butterworth
//
// METHOD: Bilinear transform scaled for exact mapping of w1.
// REFERENCE: 
//   https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html
//
tf1s(b1,b0,a0,w1) = tf1(b0d,b1d,a1d)
with {
  c   = 1/tan((w1)*0.5/SR); // bilinear-transform scale-factor
  d   = a0 + c;
  b1d = (b0 - b1*c) / d;
  b0d = (b0 + b1*c) / d;
  a1d = (a0 - c) / d;
};

//----------------------------- tf2sb --------------------------------
// Bandpass mapping of tf2s: In addition to a frequency-scaling parameter
// w1 (set to HALF the desired passband width in rad/sec),
// there is a desired center-frequency parameter wc (also in rad/s).
// Thus, tf2sb implements a fourth-order digital bandpass filter section
// specified by the coefficients of a second-order analog lowpass prototpe
// section.  Such sections can be combined in series for higher orders.
// The order of mappings is (1) frequency scaling (to set lowpass cutoff w1),
// (2) bandpass mapping to wc, then (3) the bilinear transform, with the 
// usual scale parameter 2*SR.  Algebra carried out in maxima and pasted here.
//
tf2sb(b2,b1,b0,a1,a0,w1,wc) = 
  tf4(b0d/a0d,b1d/a0d,b2d/a0d,b3d/a0d,b4d/a0d,a1d/a0d,a2d/a0d,a3d/a0d,a4d/a0d) with {
  T = 1.0/float(SR);
  b0d = (4*b0*w1^2+8*b2*wc^2)*T^2+8*b1*w1*T+16*b2;
  b1d = 4*b2*wc^4*T^4+4*b1*wc^2*w1*T^3-16*b1*w1*T-64*b2;
  b2d = 6*b2*wc^4*T^4+(-8*b0*w1^2-16*b2*wc^2)*T^2+96*b2;
  b3d = 4*b2*wc^4*T^4-4*b1*wc^2*w1*T^3+16*b1*w1*T-64*b2;
  b4d = (b2*wc^4*T^4-2*b1*wc^2*w1*T^3+(4*b0*w1^2+8*b2*wc^2)*T^2-8*b1*w1*T +16*b2)
        + b2*wc^4*T^4+2*b1*wc^2*w1*T^3;
  a0d = wc^4*T^4+2*a1*wc^2*w1*T^3+(4*a0*w1^2+8*wc^2)*T^2+8*a1*w1*T+16;
  a1d = 4*wc^4*T^4+4*a1*wc^2*w1*T^3-16*a1*w1*T-64;
  a2d = 6*wc^4*T^4+(-8*a0*w1^2-16*wc^2)*T^2+96;
  a3d = 4*wc^4*T^4-4*a1*wc^2*w1*T^3+16*a1*w1*T-64;
  a4d = wc^4*T^4-2*a1*wc^2*w1*T^3+(4*a0*w1^2+8*wc^2)*T^2-8*a1*w1*T+16;
};

//----------------------------- tf1sb --------------------------------
// First-to-second-order lowpass-to-bandpass section mapping,
// analogous to tf2sb above.
//
tf1sb(b1,b0,a0,w1,wc) = tf2(b0d/a0d,b1d/a0d,b2d/a0d,a1d/a0d,a2d/a0d) with {
  T = 1.0/float(SR);
  a0d = wc^2*T^2+2*a0*w1*T+4;
  b0d = b1*wc^2*T^2 +2*b0*w1*T+4*b1;
  b1d = 2*b1*wc^2*T^2-8*b1;
  b2d = b1*wc^2*T^2-2*b0*w1*T+4*b1;
  a1d = 2*wc^2*T^2-8;
  a2d = wc^2*T^2-2*a0*w1*T+4;
};

//====================== Simple Resonator Filters ======================

// resonlp = 2nd-order lowpass with corner resonance:
resonlp(fc,Q,gain) = tf2s(b2,b1,b0,a1,a0,wc)
with {
     wc = 2*PI*fc;
     a1 = 2/Q;
     a0 = 1;
     b2 = 0;
     b1 = 0;
     b0 = gain;
};

// resonhp = 2nd-order highpass with corner resonance:
resonhp(fc,Q,gain,x) = gain*x-resonlp(fc,Q,gain,x);

// resonbp = 2nd-order bandpass
resonbp(fc,Q,gain) = tf2s(b2,b1,b0,a1,a0,wc) 
with {
     wc = 2*PI*fc;
     a1 = 2/Q;
     a0 = 1;
     b2 = 0;
     b1 = gain;
     b0 = 0;
};

//====================== Butterworth Lowpass Filters ======================
// Reference: 
// https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html
//
//----------------------------- lowpass1 -----------------------------
// First-order Butterworth lowpass filter
// USAGE: lowpass1(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass1(fc) = tf1s(0,1,1,2*PI*fc);

//----------------------------- lowpass2 ------------------------------
// Second-order Butterworth lowpass filter
// USAGE: lowpass2(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass2(fc) = tf2s(0,0,1,sqrt(2),1,2*PI*fc);

//----------------------------- lowpass3 ------------------------------
// Third-order Butterworth lowpass filter
// USAGE: lowpass3(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass3(fc) = tf2s(0,0,1,1,1,w1) : tf1s(0,1,1,w1)
with { w1 = 2*PI*fc; };

//----------------------------- lowpass4 ------------------------------
// Fourth-order Butterworth lowpass filter
// USAGE: lowpass4(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass4(fc) = tf2s(0,0,1,a11s,1,w1) : tf2s(0,0,1,a21s,1,w1)
with {
  a11s = 1.847759065022573; // -2*real(pole1)
  a21s = 0.765366864730180; // -2*real(pole2)
  w1 = 2*PI*fc;
};

//----------------------------- lowpass5 ------------------------------
// Fifth-order Butterworth lowpass filter
// USAGE: lowpass5(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass5(fc) = 
              tf1s(0,1,1,w1) :
              tf2s(0,0,1,a11,1,w1) :
              tf2s(0,0,1,a12,1,w1)
with {
  a11 = 1.618033988749895;
  a12 = 0.618033988749895;
  w1 = 2*PI*fc;
};

//===================== Elliptic (Cauer) Lowpass Filters ===================

//----------------------------- lowpass3e -----------------------------
// Third-order Elliptic (Cauer) lowpass filter
// USAGE: lowpass3e(fc), where fc = -3dB frequency in Hz
// REFERENCE: ncauer (and ellip) functions in Octave
// DESIGN: For spectral band-slice level display (see octave_analyzer3e):
//   [z,p,g] = ncauer(Rp,Rs,3);  % analog zeros, poles, and gain, where
//   Rp = 60  % dB ripple in stopband
//   Rs = 0.2 % dB ripple in passband
//
lowpass3e(fc) = tf2s(b21,b11,b01,a11,a01,w1) : tf1s(0,1,a02,w1)
with { 
  a11 = 0.802636764161030; // format long; poly(p(1:2)) % in octave
  a01 = 1.412270893774204;
  a02 = 0.822445908998816; // poly(p(3)) % in octave
  b21 = 0.019809144837789; // poly(z)
  b11 = 0;
  b01 = 1.161516418982696;
  w1 = 2*PI*fc; 
};

//----------------------------- lowpass6 -----------------------------
// Sixth-order Butterworth lowpass filter
// USAGE: lowpass6(fc), where fc = -3dB frequency in Hz
// REFERENCE: butter function in Octave ("[z,p,g] = butter(N,1,'s');")
//
lowpass6(fc) = 
              tf2s(0,0,1,a11,1,w1) :
              tf2s(0,0,1,a12,1,w1) :
              tf2s(0,0,1,a13,1,w1)
with { 
  a11 = 1.931851652578136;
  a12 = 1.414213562373095;
  a13 = 0.517638090205041;
  w1 = 2*PI*fc; 
};

//----------------------------- lowpass6e -----------------------------
// Sixth-order Elliptic/Cauer lowpass filter
// USAGE: lowpass6e(fc), where fc = -3dB frequency in Hz
// REFERENCE: ellip function in Octave
// DESIGN: For spectral band-slice level display (see octave_analyzer6e):
//   [z,p,g] = ncauer(Rp,Rs,6);  % analog zeros, poles, and gain, where
//   Rp = 80  % dB ripple in stopband
//   Rs = 0.2 % dB ripple in passband
//
lowpass6e(fc) = 
              tf2s(b21,b11,b01,a11,a01,w1) :
              tf2s(b22,b12,b02,a12,a02,w1) :
              tf2s(b23,b13,b03,a13,a03,w1)
with { 
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;
  w1 = 2*PI*fc; 
};

//===================== Highpass Filters =====================
//
//--------------------------- highpass1-4 -----------------------------
// Butterworth highpass filters, orders 1 through 4.
// USAGE: highpassN(fc), where
// fc = desired cut-off frequency (-3dB frequency) in Hz
//  N = desired filter order (1,2,3, or 4)

highpass1(fc) = tf1s(1,0,1,2*PI*fc);
highpass2(fc) = tf2s(1,0,0,sqrt(2),1,2*PI*fc);
highpass3(fc) = tf2s(1,0,0,1,1,2*PI*fc) : tf1s(1,0,1,2*PI*fc);
highpass4(fc) = tf2s(1,0,0,a11s,1,w1)   : tf2s(1,0,0,a21s,1,w1)
with {
  a11s = 1.847759065022573; // -2*real(pole1)
  a21s = 0.765366864730180; // -2*real(pole2)
  w1 = 2*PI*fc;
};

//----------------------------- lowpass5 ------------------------------
// Fifth-order Butterworth highpass filter
// USAGE: highpass5(fc), where fc = -3dB frequency
// METHOD: Inversion of lowpass5 wrt unit circle in s plane (s <- 1/s)
//         Since the poles are on the unit circle, only the zeros move.
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
highpass5(fc) = 
              tf1s(1,0,1,w1) :
              tf2s(1,0,0,a11,1,w1) :
              tf2s(1,0,0,a12,1,w1)
with {
  a12 = 0.618033988749895;
  a11 = 1+a12;
  w1 = 2*PI*fc;
};

//----------------------------- highpass6 -----------------------------
// Sixth-order Butterworth highpass filter
// USAGE: highpass6(fc), where fc = -3dB frequency in Hz
// REFERENCE: butter function in Octave
//
lowpass6(fc) = 
              tf2s(1,0,0,a11,1,w1) :
              tf2s(1,0,0,a12,1,w1) :
              tf2s(1,0,0,a13,1,w1)
with { 
  a11 = 1.931851652578136;
  a12 = 1.414213562373095;
  a13 = 0.517638090205041;
  w1 = 2*PI*fc; 
};

//===================== Elliptic Highpass Filters =====================

//----------------------------- highpass3e -----------------------------
// Third-order Elliptic (Cauer) highpass filter
// USAGE: highpass3e(fc), where fc = -3dB frequency in Hz
// DESIGN: Inversion of lowpass3e wrt unit circle in s plane (s <- 1/s)
//
highpass3e(fc) = tf2s(b01/a01,b11/a01,b21/a01,a11/a01,1/a01,w1) : 
                 tf1s(1/a02,0,1/a02,w1)
with { 
  a11 = 0.802636764161030;
  a01 = 1.412270893774204;
  a02 = 0.822445908998816;
  b21 = 0.019809144837789;
  b11 = 0;
  b01 = 1.161516418982696;
  w1 = 2*PI*fc; 
};

//----------------------------- highpass6e -----------------------------
// Sixth-order Elliptic/Cauer highpass filter
// USAGE: highpass6e(fc), where fc = -3dB frequency in Hz
// METHOD: Inversion of lowpass3e wrt unit circle in s plane (s <- 1/s)
//
highpass6e(fc) = 
              tf2s(b01/a01,b11/a01,b21/a01,a11/a01,1/a01,w1) :
              tf2s(b02/a02,b12/a02,b22/a02,a12/a02,1/a02,w1) :
              tf2s(b03/a03,b13/a03,b23/a03,a13/a03,1/a03,w1)
with { 
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;
  w1 = 2*PI*fc; 
};

//=========== Special Filter-Bank Delay-Equalizing Allpass Filters =============

// These special allpass filters are needed by filterbank3 et al. below.
// They are equivalent to lowpassN(fc) +|- highpassN(fc), but with 
// canceling pole-zero pairs removed.

// For Butterworth filters, lowpassN + highpassN = (s^N+1)/LHP(s^(2*N)+1),
// where LHP(D(s)) means "left-half-plane roots of D(s)".  Therefore, every
// other pole is canceled by a zero.

//-------------------- lowpass3_plus|minus_highpass3 ------------------

highpass3_plus_lowpass3(fc) = tf2s(1,-1,1,1,1,w1)
with { w1 = 2*PI*fc; };

highpass3_minus_lowpass3(fc) = tf1s(-1,1,1,w1) // (more efficient)
with { w1 = 2*PI*fc; };

//-------------------- lowpass5_plus|minus_highpass5 ------------------

highpass5_plus_lowpass5(fc) = tf2s(1,-a11,1,a11,1,w1)
with { 
  a11 = 1.618033988749895;
  w1 = 2*PI*fc; 
};

highpass5_minus_lowpass5(fc) = tf1s(1,-1,1,w1) : tf2s(1,-a12,1,a12,1,w1)
with { 
  a12 = 0.618033988749895;
  w1 = 2*PI*fc; 
};

//===================== Bandpass Filters ======================

//----------------------------- bandpass6 ------------------------------
// Order 6 Butterworth bandpass filter made using the transformation
// s <- s + wc^2/s on lowpass3, where wc is the desired bandpass center 
// frequency.  The lowpass3 cutoff w1 is half the desired bandpass width.
//
// USAGE: bandpass6(fl,fu), where 
//   fl = lower -3dB frequency in Hz
//   fu = upper -3dB frequency in Hz
// Thus, the passband width is fu-fl, and its center frequency is (fl+fu)/2.
//
// REFERENCE: 
//   http://cnx.org/content/m16913/latest/
//
bandpass6(fl,fu) = tf2sb(0,0,1,1,1,w1,wc) : tf1sb(0,1,1,w1,wc) 
//      lowpass3 is tf2s(0,0,1,1,1,w1)    :  tf1s(0,1,1,w1)
with { 
   wl = 2*PI*fl; // digital (z-plane) lower passband edge
   wu = 2*PI*fu; // digital (z-plane) upper passband edge

   c = 2.0*SR; // bilinear transform scaling used in tf2sb, tf1sb
   wla = c*tan(wl/c); // analog (s-splane) lower cutoff
   wua = c*tan(wu/c); // analog (s-splane) upper cutoff

   wc = sqrt(wla*wua); // s-plane center frequency
   w1 = wua - wc^2/wua; // s-plane lowpass prototype cutoff
};

//----------------------------- bandpass6e -----------------------------
// Order 12 elliptic bandpass filter analogous to bandpass6 above.
//
bandpass6e(fl,fu) = tf2sb(b21,b11,b01,a11,a01,w1,wc) : tf1sb(0,1,a02,w1,wc)
with { 
  a11 = 0.802636764161030; // In octave: format long; poly(p(1:2))
  a01 = 1.412270893774204;
  a02 = 0.822445908998816; // poly(p(3))
  b21 = 0.019809144837789; // poly(z)
  b11 = 0;
  b01 = 1.161516418982696;

  wl = 2*PI*fl; // digital (z-plane) lower passband edge
  wu = 2*PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-splane) lower cutoff
  wua = c*tan(wu/c); // analog (s-splane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass cutoff
};

//----------------------------- bandpass12e -----------------------------
// Sixth-order Elliptic bandpass filter analogous to bandpass6 above.
//
bandpass12e(fl,fu) = 
              tf2sb(b21,b11,b01,a11,a01,w1,wc) :
              tf2sb(b22,b12,b02,a12,a02,w1,wc) :
              tf2sb(b23,b13,b03,a13,a03,w1,wc)
with { // octave script output:
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;

  wl = 2*PI*fl; // digital (z-plane) lower passband edge
  wu = 2*PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-splane) lower cutoff
  wua = c*tan(wu/c); // analog (s-splane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass cutoff
};

//================= Parametric Equalizers (Shelf, Peaking)  ====================
// REFERENCES
// - http://en.wikipedia.org/wiki/Equalization
// - Digital Audio Signal Processing, Udo Zolzer, Wiley, 1999, p. 124
// - http://www.harmony-central.com/Computer/Programming/Audio-EQ-Cookbook.txt
//   http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
// - https://ccrma.stanford.edu/~jos/filters/Low_High_Shelving_Filters.html
// - https://ccrma.stanford.edu/~jos/filters/Peaking_Equalizers.html
// - maxmsp.lib in the Faust distribution
// - bandfilter.dsp in the faust2pd distribution 

//----------------------------- low_shelf --------------------------------------
// First-order "low shelf" filter (gain boost|cut between dc and some frequency)
// USAGE: lowshelf(L0,fx), where
//  L0 = desired boost (dB) between dc and fx
//  fx = desired transition frequency (Hz) from boost to unity gain
// The gain at SR/2 is constrained to be 1.
//
low_shelf = low_shelf3; // default
low_shelf1(L0,fx,x) = x + (db2linear(L0)-1)*lowpass1(fx,x);
low_shelf3(L0,fx,x) = x + (db2linear(L0)-1)*lowpass3(fx,x);
low_shelf5(L0,fx,x) = x + (db2linear(L0)-1)*lowpass5(fx,x);

//----------------------------- high_shelf ------------------------------------
// First-order "high shelf" filter (gain boost|cut above some frequency)
//
// USAGE: high_shelf(Lpi,fx), where
//  Lpi = desired boost or cut (dB) between fx and SR/2
//  fx = desired transition frequency in Hz
// The gain at dc is constrained to be 1
//
high_shelf=high_shelf3; //default
high_shelf1(Lpi,fx,x) = x + (db2linear(Lpi)-1)*highpass1(fx,x);
high_shelf3(Lpi,fx,x) = x + (db2linear(Lpi)-1)*highpass3(fx,x);
high_shelf5(Lpi,fx,x) = x + (db2linear(Lpi)-1)*highpass5(fx,x);

//-------------------------------- peak_eq ------------------------------------
// second order "peaking equalizer" section 
// (gain boost or cut near some frequency)
//   Also called a "parametric equalizer" section
// USAGE: peak_eq(Lfx,fx,B)
//  Lfx : level (dB) at fx
//   fx : peak frequency (Hz)
//    B : bandwidth (B) of peak
//
peak_eq(Lfx,fx,B) = tf2s(1,g*B,1,B,1,wx) with {
  g = db2linear(Lfx);
  wx = 2*PI*fx;
};  

//-------------------------- parametric_eq_demo --------------------------------
// USAGE: _ : parametric_eq_demo: _ ;
parametric_eq_demo = // input_signal : 
	low_shelf(LL,FL) :
	peak_eq(LP,FP,BP) :
	high_shelf(LH,FH)
// Recommended: 
//       : mth_octave_spectral_level_demo(2) // half-octave spectrum analyzer
with {
  eq_group(x) = hgroup("[0] Parametric EQ Sections 
                [tooltip: See Faust's filter.lib for info and pointers",x);

  ls_group(x) = eq_group(vgroup("[1] Low Shelf",x));
  LL = ls_group(hslider("[0] Low Boost|Cut [unit:dB] [style:knob]
                [tooltip: Amount of low-frequency boost or cut in decibels]",
                0,-40,40,0.1));
  FL = ls_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob]
                [tooltip: Transition frequency from boost (cut) to unity gain]",
                200,1,10000,1));

  pq_group(x) = eq_group(vgroup("[2] Low Shelf, Peaking Equalizer, High Shelf
                [tooltip: Parametric Equalizer sections from filter.lib]",x));
  LP = pq_group(hslider("[0] Peak Boost|Cut [unit:dB] [style:knob]
                [tooltip: Amount of local boost or cut in decibels]",
                0,-40,40,0.1));
  FP = pq_group(hslider("[1] Peak Frequency [unit:Hz] [style:knob]
                [tooltip: ]",
                500,1,10000,1));
   Q = pq_group(hslider("[2] Peak Q [style:knob]
                [tooltip: ]",
                40,0,100,0.1)) : db2linear;
  BP = FP/Q; // rough bandwidth calculation from Q

  hs_group(x) = eq_group(vgroup("[3] High Shelf 
                [tooltip: A high shelf provides a boost or cut 
                          above some frequency]",x));
  LH = hs_group(hslider("[0] High Boost|Cut [unit:dB] [style:knob]
                [tooltip: Amount of high-frequency boost or cut in decibels]",
                0,-40,40,.1));
  FH = hs_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob]
                [tooltip: ]",
                8000,1,10000,1));

};

//========================= Lagrange Interpolation ========================
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html
// 
//------------------ fdelay1, fdelay2, fdelay3, fdelay4 ---------------
// Delay lines interpolated using Lagrange interpolation
// USAGE: fdelayN(maxdelay, delay, inputsignal) 
//        (exactly like fdelay in music.lib)
// where N=1,2,3, or 4 is the order of the Lagrange interpolation polynomial.
//
// NOTE: requested delay should not be less than (N-1)/2.
//
// NOTE: While the implementations below appear to use multiple delay lines,
//  they in fact use only one thanks to optimization by the Faust compiler.

// first-order case (linear interpolation) - equivalent to fdelay in music.lib
// delay d in [0,1] 
fdelay1(n,d,x)  = delay(n,id,x)*(1 - fd) + delay(n,id+1,x)*fd
with {
  id = int(d);
  fd = frac(d);
};

// second-order (quadratic) case, delay in [0.5,1.5]
// delay d should be at least 0.5
fdelay2(n,d,x) = delay(n,id,x)*(1-fd)*(2-fd)/2 
               + delay(n,id+1,x)*(2-fd)*fd
               + delay(n,id+2,x)*(fd-1)*fd/2
with {
  o = 0.49999; // offset to make life easy for interpolator
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
};

// third-order (cubic) case, delay in [1,2]
// delay d should be at least 1
fdelay3(n,d,x) = delay(n,id,x) * (0-fdm1*fdm2*fdm3)/6
               + delay(n,id+1,x) * fd*fdm2*fdm3/2
               + delay(n,id+2,x) * (0-fd*fdm1*fdm3)/2
               + delay(n,id+3,x) * fd*fdm1*fdm2/6
with {
  id = int(d-1); 
  fd = 1+frac(d);
  fdm1 = fd-1;
  fdm2 = fd-2;
  fdm3 = fd-3;
};

// fourth-order (quartic) case, delay in [1.5,2.5]
// delay d should be at least 1.5
fdelay4(n,d,x) = delay(n,id,x)   * fdm1*fdm2*fdm3*fdm4/24 
               + delay(n,id+1,x) * (0-fd*fdm2*fdm3*fdm4)/6
               + delay(n,id+2,x) * fd*fdm1*fdm3*fdm4/4
               + delay(n,id+3,x) * (0-fd*fdm1*fdm2*fdm4)/6
               + delay(n,id+4,x) * fd*fdm1*fdm2*fdm3/24
with {
//v1:  o = 1;
  o = 1.49999;
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
  fdm1 = fd-1;
  fdm2 = fd-2;
  fdm3 = fd-3;
  fdm4 = fd-4;
};

// fifth-order case, delay in [2,3]
// delay d should be at least 2
fdelay5(n,d,x) = 
   delay(n,id,x)   *    -fdm1*fdm2*fdm3*fdm4*fdm5/120
 + delay(n,id+1,x) *  fd*     fdm2*fdm3*fdm4*fdm5/24
 + delay(n,id+2,x) * -fd*fdm1*     fdm3*fdm4*fdm5/12
 + delay(n,id+3,x) *  fd*fdm1*fdm2*     fdm4*fdm5/12
 + delay(n,id+4,x) * -fd*fdm1*fdm2*fdm3*     fdm5/24
 + delay(n,id+5,x) *  fd*fdm1*fdm2*fdm3*fdm4     /120
with {
//v1:  o = 1;
  o = 1.99999;
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
  fdm1 = fd-1;
  fdm2 = fd-2;
  fdm3 = fd-3;
  fdm4 = fd-4;
  fdm5 = fd-5;
};

//====================== Thiran Allpass Interpolation =====================
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html
// 
//---------------- fdelay1a, fdelay2a, fdelay3a, fdelay4a -------------
// Delay lines interpolated using Thiran allpass interpolation
// USAGE: fdelayNa(maxdelay, delay, inputsignal) 
//        (exactly like fdelay in music.lib)
// where N=1,2,3, or 4 is the order of the Thiran interpolation filter,
// and the delay argument is at least N - 1/2.
//
// (Move the following and similar notes above to filter-lib-doc.txt?)
//
// NOTE: The interpolated delay should not be less than N - 1/2.
//            (The allpass delay ranges from N - 1/2 to N + 1/2.)
//            This constraint can be alleviated by altering the code,
//            but be aware that allpass filters approach zero delay
//            by means of pole-zero cancellations.
//            The delay range [N-1/2,N+1/2] is not optimal. What is?
//
// NOTE: Delay arguments too small will produce an UNSTABLE allpass!
//
// NOTE: Because allpass interpolation is recursive, it is not as robust
//       as Lagrange interpolation under time-varying conditions.
//       (You may hear clicks when changing the delay rapidly.)
//
// first-order allpass interpolation, allpass delay in [0.5,1.5]
// delay d should be at least 0.5
fdelay1a(n,d,x)  = delay(n,id,x) : tf1(eta,1,eta)
with {
  o = 0.49999; // offset to make life easy for allpass
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
  eta = (1-fd)/(1+fd); // allpass coefficient
};

// second-order allpass delay in [1.5,2.5]
// delay d should be at least 1.5
fdelay2a(n,d,x) = delay(n,id,x) : tf2(a2,a1,1,a1,a2)
with {
  o = 1.49999;
  dmo = d - o; // delay range is [order-1/2, order+1/2]
  id = int(dmo);
  fd = o + frac(dmo);
  a1o2 = (2-fd)/(1+fd); // share some terms (the compiler does this anyway)
  a1 = 2*a1o2;
  a2 = a1o2*(1-fd)/(2+fd);
};

// third-order allpass delay in [2.5,3.5]
// delay d should be at least 2.5
fdelay3a(n,d,x) = delay(n,id,x) : tf3(a3,a2,a1,1,a1,a2,a3)
with {
  o = 2.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + frac(dmo);
  a1o3 = (3-fd)/(1+fd);
  a2o3 = a1o3*(2-fd)/(2+fd);
  a1 = 3*a1o3;
  a2 = 3*a2o3;
  a3 = a2o3*(1-fd)/(3+fd);
};

// fourth-order allpass delay in [3.5,4.5]
// delay d should be at least 3.5
fdelay4a(n,d,x) = delay(n,id,x) : tf4(a4,a3,a2,a1,1,a1,a2,a3,a4)
with {
  o = 3.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + frac(dmo);
  a1o4 = (4-fd)/(1+fd);
  a2o6 = a1o4*(3-fd)/(2+fd);
  a3o4 = a2o6*(2-fd)/(3+fd);
  a1 = 4*a1o4;
  a2 = 6*a2o6;
  a3 = 4*a3o4;
  a4 = a3o4*(1-fd)/(4+fd);
};

//================= Mth-Octave Filter-Banks and Spectrum-Analyzers =============
// Mth-octave filter-banks and spectrum-analyzers split the input signal into a
// bank of parallel signals, one for each spectral band. The parameters are
//
//   M = number of band-slices per octave (>1)
//   N = total number of bands (>2)
//   ftop = upper bandlimit of the Mth-octave bands (<SR/2)
//
// In addition to the Mth-octave output signals, there is a highpass signal
// containing frequencies from ftop to SR/2, and a "dc band" lowpass signal 
// containing frequencies from 0 (dc) up to the start of the Mth-octave bands.
// Thus, the N output signals are
//
//   highpass(ftop), MthOctaveBands(M,N-2,ftop), dcBand(ftop*2^(-M*(N-1)))
//
// A FILTER-BANK is defined here as a signal bandsplitter having the
// property that summing its output signals gives an allpass-filtered
// version of the filter-bank input signal.  A more conventional term for
// this is an "allpass-complementary filter bank".  If the allpass filter
// is a pure delay (and possible scaling), the filter bank is said to be
// a "perfect-reconstruction filter bank" (see Vaidyanathan-1993 cited
// below for details).  A "graphic equalizer", in which band signals
// are scaled by gains and summed, should be based on a filter bank.
//
// A SPECTRUM-ANALYZER is defined here as any band-split whose bands span
// the relevant spectrum, but whose band-signals do not
// necessarily sum to the original signal, either exactly or to within an
// allpass filtering. Spectrum analyzer outputs are normally at least nearly
// "power complementary", i.e., the power spectra of the individual bands
// sum to the original power spectrum (to within some negligible tolerance).
//
// The filter-banks below are implemented as Butterworth spectrum-analyzers 
// followed by delay equalizers that make them allpass-complementary.
//
// INCREASING CHANNEL ISOLATION
//   Go to higher filter orders - see Regalia et al. or Vaidyanathan (cited 
//   below) regarding the construction of more aggressive recursive 
//   filter-banks using elliptic or Chebyshev prototype filters.
//   
// REFERENCES
// - "Tree-structured complementary filter banks using all-pass sections",
//   Regalia et al., IEEE Trans. Circuits & Systems, CAS-34:1470-1484, Dec. 1987
// - "Multirate Systems and Filter Banks", P. Vaidyanathan, Prentice-Hall, 1993
// - Elementary filter theory: https://ccrma.stanford.edu/~jos/filters/
//
//------------------------- mth_octave_analyzer ----------------------------
//
// USAGE
//    _ : mth_octave_analyzer  (M,ftop,N) : par(i,N,_); // default analyzer
//    _ : mth_octave_analyzer3 (M,ftop,N) : par(i,N,_); // 3rd-order Butterworth
//    _ : mth_octave_analyzer5 (M,ftop,N) : par(i,N,_); // 5th-order Butterworth
//    _ : mth_octave_analyzer6e(M,ftop,N) : par(i,N,_); // 6th-order elliptic
//
// where 
//   M = number of band-slices per octave
//   ftop = highest band-split crossover frequency (e.g., 20 kHz)
//   N = total number of bands (including dc and Nyquist)
//
// The suffix '5'  means fifth-order Butterworth band-splitters.
// The suffix '6e' means sixth-order elliptic band-splitters.
// No-suffix means "default", which may change in future versions.
//
// ACKNOWLEDGMENT
//  Recursive band-splitting formulation improved by Yann Orlarey.

mth_octave_analyzer6e(M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  lp(n) = lowpass6e(fc(n));  // 6th-order elliptic - see other choices above
  hp(n) = highpass6e(fc(n)); //   (search for lowpass* and highpass*)
  bsplit(0)  = _; 
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

// The following Butterworth analyzers may be cascaded with allpass
// delay-equalizers to make (allpass-complementary) filter banks:

mth_octave_analyzer3(M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M));
  lp(n) = lowpass3(fc(n)); // 3rd-order Butterworth
  hp(n) = highpass3(fc(n));
  bsplit(0)  = _; 
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

mth_octave_analyzer5(M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M));
  lp(n) = lowpass5(fc(n)); // 5th-order Butterworth
  hp(n) = highpass5(fc(n));
  bsplit(0)  = _; 
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

mth_octave_analyzer = mth_octave_analyzer6e; // default analyzer

//---------------------- mth_octave_filterbank[3|3i|5] ------------------------
// Allpass-complementary filter banks based on Butterworth band-splitting.
// For Butterworth band-splits, the needed delay equalizer is easily found.

mth_octave_filterbank3(M,ftop,N) = 
    mth_octave_analyzer3(M,ftop,N) : 
    delayeq(N) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  ap(n) = highpass3_plus_lowpass3(fc(n)); // delay-equalizing allpass
  delayeq(N) = par(i,N-2,apchain(i+1)), _, _;
  apchain(i) = seq(j,N-1-i,ap(j+1));
};

// dc-inverted version.  This cuts the delay-equalizer order in half.
// Note that you can negate the input signal so that the dc band is noninverting
// and all higher bands become sign-inverted (if preferred).
mth_octave_filterbank3i(M,ftop,N) = 
    mth_octave_analyzer3(M,ftop,N) : 
    delayeqi(N) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  ap(n) = highpass3_minus_lowpass3(fc(n)); // half the order of 'plus' case
  delayeqi(N) = par(i,N-2,apchain(i+1)), _, *(-1.0);
  apchain(i) = seq(j,N-1-i,ap(j+1));
};

// Note that even-order cases require complex coefficients.
// See Vaidyanathan 1993 and papers cited there for more info.

mth_octave_filterbank5(M,ftop,N) = 
    mth_octave_analyzer5(M,ftop,N) : 
    delayeq(N) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  ap5(n) = highpass5_plus_lowpass5(fc(n)); // delay-equalizing allpass
  delayeq(N) = par(i,N-2,apchain(i+1)), _, _;
  apchain(i) = seq(j,N-1-i,ap5(j+1));
};

// No dc-inverted '5i' version, because the noninverted version is more efficient

mth_octave_filterbank = mth_octave_filterbank5;  // default filterbank

//======================= Mth-Octave Spectral Level =========================
// Spectral Level: Display (in bar graphs) the average signal level in each 
//                 spectral band.
//
//------------------------ mth_octave_spectral_level -------------------------
// USAGE: _ : mth_octave_spectral_level(M,ftop,NBands,tau,dB_offset);
// where 
//    M = bands per octave
//    ftop = lower edge frequency of top band
//    NBands = number of passbands (including highpass and dc bands),
//    tau = spectral display averaging-time (time constant) in seconds,
//    dB_offset = constant dB offset in all band level meters.
//
mth_octave_spectral_level6e(M,ftop,N,tau,dB_offset) = _<:
    _,mth_octave_analyzer6e(M,ftop,N) : 
    _,(display:>_):attach with {
  display = par(i,N,dbmeter(i));
  dbmeter(i) = abs : smooth(tau2pole(tau)) : linear2db : +(dB_offset) : 
     meter(N-i-1);
  meter(i) = speclevel_group(vbargraph("%2i [unit:dB] 
     [tooltip: Spectral Band Level in dB]", -50, 10));
  // Can M be included in the label string somehow?
  speclevel_group(x)  = hgroup("CONSTANT-Q SPECTRUM ANALYZER (6E)
                   [tooltip: See Faust filter.lib for documentation]", x);
};

mth_octave_spectral_level = mth_octave_spectral_level6e; // default
spectral_level = mth_octave_spectral_level(2,10000,20);  // high-level default

//---------------------- mth_octave_spectral_level_demo ------------------------
// Demonstrate mth_octave_spectral_level in a standalone GUI.
//
// USAGE:  _ : mth_octave_spectral_level_demo(BandsPerOctave);

mth_octave_spectral_level_demo(M) = 
  mth_octave_spectral_level(M,ftop,N,tau,dB_offset) 
with {
  // Span nearly 10 octaves so that lowest band-edge is at 
  // ftop*2^(-Noct+2) = 40 Hz when ftop=10 kHz:
  N = 10*M;
  ftop = 10000;
  ctl_group(x)  = hgroup("SPECTRUM ANALYZER CONTROLS", x);
  tau = ctl_group(hslider("[0] Level Averaging Time [unit:sec]
        [tooltip: band-level averaging time]",
        0.1,0,1,0.01)); 
  dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
        [tooltip: Level offset in decibels]",
        50,0,100,1)); 
};

spectral_level_demo = mth_octave_spectral_level_demo(1); // octave analyzer

//---------------- (third|half)_octave_(analyzer|filterbank) -------------------

// Named special cases of mth_octave_* with defaults filled in:

third_octave_analyzer(N) = mth_octave_analyzer(3,10000,N);
third_octave_filterbank(N) = mth_octave_filterbank(3,10000,N);
// Third-Octave Filter-Banks have been used in audio for over a century.
// See, e.g.,
//   Acoustics [the book], by L. L. Beranek
//   Amer. Inst. Physics for the Acoustical Soc. America,
//   http://asa.aip.org/publications.html, 1986 (1st ed.1954)

// Third-octave bands across the audio spectrum are too wide for current
// typical computer screens, so half-octave bands are the default:
half_octave_analyzer(N) = mth_octave_analyzer(2,10000,N);
half_octave_filterbank(N) = mth_octave_filterbank(2,10000,N);

octave_filterbank(N) = mth_octave_filterbank(1,10000,N); // yet more compact
octave_analyzer(N) = mth_octave_analyzer(1,10000,N);

//=========================== Filter-Bank Demos ===============================
// Graphic Equalizer: Each filter-bank output signal routes through a fader.
//
// USAGE: _ : mth_octave_filterbank_demo(M) : _; 
// where M = number of bands per octave

mth_octave_filterbank_demo(M) = bp1(bp,mthoctavefilterbankdemo) with {
   bp1 = component("effect.lib").bypass1;
   mofb_group(x)  = vgroup("CONSTANT-Q FILTER BANK (Butterworth)
                   [tooltip: See Faust filter.lib for documentation]", x);
   bypass_group(x) = mofb_group(hgroup("[0]", x));
   slider_group(x)  = mofb_group(hgroup("[1]", x));
   N = 10*M; // total number of bands (highpass band, octave-bands, dc band)
   ftop = 10000;
   mthoctavefilterbankdemo = chan;
   chan = mth_octave_filterbank(M,ftop,N) : sum(i,N,(*(db2linear(fader(N-i)))));
   fader(i) = slider_group(vslider("Band %2i [unit:dB]
              [tooltip: Filter Band gain in dB]", -10, -120, 10, 0.1)) : 
              smooth(0.999);
   bp = bypass_group(checkbox("[0] Bypass  
              [tooltip: When this is checked, the filter-bank has no effect]"));
};

filterbank_demo = mth_octave_filterbank_demo(1); // octave-bands = default

//=========== Arbritary-Crossover Filter-Banks and Spectrum Analyzers ==========
// These are similar to the Mth-octave filter-banks above, except that the
// band-split frequencies are passed explicitly as arguments. 
//
// USAGE:
//    _ : filterbank3 (freqs) : par(i,N,_);
//    _ : filterbank3i(freqs) : par(i,N,_);
//    _ : filterbank5 (freqs) : par(i,N,_);
//    _ : analyzer3   (freqs) : par(i,N,_);
//    _ : analyzer5   (freqs) : par(i,N,_);
//
// where freqs = (fc1,fc2,...,fcNs) [in numerically ascending order], and
// Ns=N-1 is the number of octave band-splits (total number of bands N=Ns+1). If
// frequencies are listed explicitly as arguments, enclose them in parens, e.g.,
//
//    _ : filterbank3((fc1,fc2)) : _,_,_
//
// ACKNOWLEDGMENT
//    Technique for processing a variable number of signal arguments due
//    to Yann Orlarey (as is the entire Faust framework!)
//
//----------------------------- filterbank3 -------------------------------

// Perhaps these general-purpose utilities should go in math.lib?
count ((xs, xxs)) = 1 + count(xxs);
count (xx) = 1;
take(1, (freq, lfreq)) = freq;
take(1, freq) = freq;
take(n, (freq, lfreq)) = take(n-1, lfreq);

analyzer3(lfreqs) = _ <: bsplit(nb) with
{
   nb = count(lfreqs);
   fc(n) = take(n, lfreqs);
   lp(n) = lowpass3(fc(n));  // 3rd-order Butterworth
   hp(n) = highpass3(fc(n));
   bsplit(0) = _;
   bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

filterbank3(lfreqs) = analyzer3(lfreqs) : delayeq with
{
   nb = count(lfreqs);
   fc(n) = take(n, lfreqs);
   ap(n) = highpass3_plus_lowpass3(fc(n));
   delayeq = par(i,nb-1,apchain(nb-1-i)),_,_;
   apchain(0) = _;
   apchain(i) =  ap(i) : apchain(i-1);
};

filterbank3i(lfreqs) = _ <: bsplit(nb) with
{
   fc(n) = take(n, lfreqs);
   lp(n) = lowpass3(fc(n));  // 3rd-order Butterworth
   hp(n) = highpass3(fc(n));
   ap(n) = highpass3_minus_lowpass3(fc(n));
   bsplit(0) = *(-1.0);
   bsplit(i) = (hp(i) : delayeq(i-1)), (lp(i) <: bsplit(i-1));
   delayeq(0) = _; // moving the *(-1) here inverts all outputs BUT dc
   delayeq(i) =  ap(i) : delayeq(i-1);
};

analyzer5(lfreqs) = _ <: bsplit(nb) with
{
   nb = count(lfreqs);
   fc(n) = take(n, lfreqs);
   lp(n) = lowpass5(fc(n));  // 5th-order Butterworth
   hp(n) = highpass5(fc(n));
   bsplit(0) = _;
   bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

filterbank5(lfreqs) = analyzer5(lfreqs) : delayeq with
{
   nb = count(lfreqs);
   fc(n) = take(n, lfreqs);
   ap(n) = highpass5_plus_lowpass5(fc(n));
   delayeq = par(i,nb-1,apchain(nb-1-i)),_,_;
   apchain(0) = _;
   apchain(i) =  ap(i) : apchain(i-1);
};
