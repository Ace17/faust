// filter.lib - filters of various types useful in audio

declare name "Faust Effect Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.0";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "http://ccrma.stanford.edu/realsimple/faust_strings/";

import("filter.lib"); // dcblocker*, lowpass4, ...

//------------------------ levelfilter --------------------------
// Dynamic level lowpass filter:
// Reference: http://ccrma.stanford.edu/realsimple/faust_strings/
levelfilter(L,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = PI*freq/SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};

//------------------------ speakerbp -----------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to 
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a 
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
// speakerbp(130,5000);
//
// Requires filter.lib

speakerbp(f1,f2) = dcblockerat(f1) : dcblockerat(f1) : lowpass4(f2);

//--------------------- cubicnl(drive,offset) -----------------------
// Cubic nonlinearity distortion
// USAGE: cubicnl(drive,offset), where
//   drive  = distortion amount, between 0 and 1
//   offset = constant added before nonlinearity to give even harmonics
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html#18254

cubicnl(drive,offset) = +(offset) 
			 : *(pregain) : clippedcubic : *(postgain) 
			 : dcblocker
with {
  tt = 2.0/3.0;
  // sel(x) = 1 - (x < -1) + (x > 1); // 0,1,2
  // clippedcubic(x) = select3(sel(x), 0-tt, x - pow(x,3)/3.0, tt);
  stage1(x) = select2(x>(-1.0), 0-tt, x - pow(x,3)/3.0);
  clippedcubic(x) = select2(x>1.0, stage1(x), tt);
  pregain = pow(10.0,2*drive);
  postgain = max(1.0,(1.0/(pregain))); // unity gain when nearly linear
};

//------------------------ moogvcf(Q,fr) ---------------------------
// Moog "Voltage Controlled Filter" (VCF)
//
// USAGE: moogvcf(Q,fr), where
//   fr = corner-resonance frequency in Hz ( less than SR/6.3 or so )
//   Q  = corner-resonance quality factor Q
// 
moogvcf(Q,fr) = (+ : pole(p) : pole(p) 
                   : pole(p) : pole(p) : *(scale(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * PI / SR; // approx for fr << SR
     scale(p) = pow(1-p,4);
     mk = 0-Q;
};

//-------------------------- wah4(fr) -------------------------------
// Wah effect, 4th order
// USAGE: wah4(fr), where fr = resonance frequency in Hz
// 
wah4(fr) = moogvcf(3.8,fr); // Q fixed at ~ 3.8 (set to taste)

//------------------------ crybaby(wah) -----------------------------
// Digitized CryBaby wah pedal
// USAGE: crybaby(wah), where wah = "pedal angle" from 0 to 1.
// Requires filter.lib.
//
crybaby(wah) = *(gs(s)) : tf2(1,-1,0,a1s(s),a2s(s))
with {
  s = 0.999; // smoothing parameter (one-pole pole location)
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/SR; // Normalized pole frequency (cycles per sample)
  R = 1 - PI*frn/Q; // pole radius
  theta = 2*PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  a1s(s) = a1 : smooth(s);
  a2s(s) = a2 : smooth(s);
  gs(s) =  g  : smooth(s);
};

