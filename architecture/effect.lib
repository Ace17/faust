declare name "Faust Effect Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.1";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "http://ccrma.stanford.edu/realsimple/faust_strings/";

import("filter.lib"); // dcblocker*, lowpass4, ...

//--------------- levelfilter, levelfilterN -----------------------
// Dynamic level lowpass filter:
// USAGE: levelfilter(L,freq), where
//  L    = desired level (in dB) at Nyquist limit (SR/2), e.g., -60
//  freq = corner frequency (-3dB point) usually set to fundamental freq
//
// Reference: 
// http://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html
//
levelfilter(L,freq,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = PI*freq/SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};

levelfilterN(N,freq,L) = seq(i,N,levelfilter((L/N),freq));

//------------------------- speakerbp -------------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to 
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a 
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
// speakerbp(130,5000);
//
// Requires filter.lib
//
speakerbp(f1,f2) = dcblockerat(f1) : dcblockerat(f1) : lowpass4(f2);


//--------------------- cubicnl(drive,offset) -----------------------
// Cubic nonlinearity distortion
// USAGE: cubicnl(drive,offset), where
//   drive  = distortion amount, between 0 and 1
//   offset = constant added before nonlinearity to give even harmonics
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html#18254
//
cubicnl(drive,offset) =
   +(offset) : *(pregain) : clip(-1,1) : cubic : dcblocker
with {
    pregain = pow(10.0,2*drive);
    clip(lo,hi) = min(hi) : max(lo);
    cubic(x) = x - x*x*x/3;
    postgain = max(1.0,1.0/pregain); // unity gain when nearly linear
};


//------------------------- moogvcf(Q,fr) ---------------------------
// Moog "Voltage Controlled Filter" (VCF)
//
// USAGE: moogvcf(Q,fr), where
//   fr = corner-resonance frequency in Hz ( less than SR/6.3 or so )
//   Q  = corner-resonance quality factor Q
// Requires filter.lib.
// Reference "http://ccrma.stanford.edu/~jos/pasp/vegf.html";
// 
moogvcf(Q,fr) = (+ : pole(p) : pole(p) 
                   : pole(p) : pole(p) : *(scale(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * PI / SR; // approx for fr << SR
     scale(p) = pow(1-p,4);
     mk = 0-Q;
};


//-------------------------- wah4(fr) -------------------------------
// Wah effect, 4th order
// USAGE: wah4(fr), where fr = resonance frequency in Hz
// Reference "http://ccrma.stanford.edu/~jos/pasp/vegf.html";
// 
wah4(fr) = moogvcf(3.8,fr); // Q fixed at ~ 3.8 (set to taste)


//------------------------ crybaby(wah) -----------------------------
// Digitized CryBaby wah pedal
// USAGE: crybaby(wah), where wah = "pedal angle" from 0 to 1.
// Requires filter.lib.
// Reference "http://ccrma.stanford.edu/~jos/pasp/vegf.html";
//
crybaby(wah) = *(gs(s)) : tf2(1,-1,0,a1s(s),a2s(s))
with {
  s = 0.999; // smoothing parameter (one-pole pole location)
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/SR; // Normalized pole frequency (cycles per sample)
  R = 1 - PI*frn/Q; // pole radius
  theta = 2*PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  a1s(s) = a1 : smooth(s);
  a2s(s) = a2 : smooth(s);
  gs(s) =  g  : smooth(s);
};

//------------ pianodispersionfilter(M,B,f0) ---------------
// Piano dispersion allpass filter in closed form 
//
// ARGUMENTS:
//   M = number of first-order allpass sections (compile-time only)
//       Keep below 20. 8 is typical for medium-sized piano strings.
//   B = string inharmonicity coefficient (0.0001 is typical)
//  f0 = fundamental frequency in Hz
//
// INPUT:
//   Signal to be filtered by the allpass chain
//
// OUTPUTS:
//  1. MINUS the estimated delay at f0 of allpass chain in samples,
//     provided in negative form to facilitate subtraction
//     from delay-line length (see USAGE below).
//  2. Output signal from allpass chain
//
// USAGE:
//  pianodispersionfilter(1,B,f0) : +(totalDelay),_ : fdelay(maxDelay)
//
// Reference: 
//   "Dispersion Modeling in Waveguide Piano Synthesis
//    Using Tunable Allpass Filters",
//   by Jukka Rauhala and Vesa Valimaki, DAFX-2006, pp. 71-76
//   URL: http://www.dafx.ca/proceedings/papers/p_071.pdf
//   NOTE: An erratum in Eq. (7) is corrected in Dr. Rauhala's 
//    encompassing dissertation (and below).
//   See also: http://www.acoustics.hut.fi/research/asp/piano/
//
pianodispersionfilter(M,B,f0) = -Df0*M,seq(i,M,tf1(a1,1,a1))
with {
 a1 = (1-D)/(1+D); // By Eq. 3, have D >= 0, hence a1 >= 0 also
 D = exp(Cd - Ikey(f0)*kd); 
 trt = pow(2.0,1.0/12.0); // 12th root of 2
 logb(b,x) = log(x) / log(b); // log-base-b of x
 Ikey(f0) = logb(trt,f0*trt/27.5);
 Bc = max(B,0.000001);
 kd = exp(k1*log(Bc)*log(Bc) + k2*log(Bc)+k3);
 Cd = exp((m1*log(M)+m2)*log(Bc)+m3*log(M)+m4);
 k1 = -0.00179;
 k2 = -0.0233;
 k3 = -2.93;
 m1 = 0.0126;
 m2 = 0.0606;
 m3 = -0.00825;
 m4 = 1.97;
 wT = 2*PI*f0/SR;
 polydel(a) = atan(sin(wT)/(a+cos(wT)))/wT;
 Df0 = polydel(a1) - polydel(1.0/a1);
};

//------- flangermono, flangerstereo, flangerstereoapp -------
// The flanging effect
//
// USAGE:
//   flangermono(dmax,curdel,depth,fb,invert);
//   flangerstereo(dmax,curdel1,curdel2,depth,fb,invert);
//
// ARGUMENTS:
//   dmax   = maximum delay-line length (power of 2) - 10 ms typical
//   curdel = current dynamic delay (not to exceed dmax)
//   depth  = effect strength between 0 and 1 (1 typical)
//   fb     = feedback gain between 0 and 1 (0 typical)
//   invert = 0 for normal, 1 to invert sign of flanging sum
//
// Reference: 
//    https://ccrma.stanford.edu/~jos/pasp/Flanging.html
//
flangermono(dmax,curdel,depth,fb,invert)
  = _ <: _, (-:fdelay(dmax,curdel)) ~ *(fb) : _, 
  *(select2(invert,depth,0-depth)) 
  : + : *(0.5);

flangerstereo(dmax,curdel1,curdel2,depth,fb,invert)
  =  flangermono(dmax,curdel1,depth,fb,invert),
     flangermono(dmax,curdel2,depth,fb,invert);

// Standalone flanger app or plugin
//
// USAGE: 
//   process = component("effect.lib").flangerstereoapp;
//
flangerstereoapp = *(level),*(level) : flangerstereo(dmax,curdel1,curdel2,depth,fb,invert)
with {
  lfol = component("osc.lib").oscrs; // sine for left channel
  lfor = component("osc.lib").oscrc; // cosine for right channel
  dmax = 2048;
  dflange = 0.001 * SR * hslider("flange delay [unit:ms]", 10, 0, 20, 0.001);
  odflange = 0.001 * SR * hslider("flange delay offset [unit:ms]", 1, 0, 20, 0.001);
  freq	 = hslider("LFO freq [unit:Hz]", 0.2, 0, 5, 0.001);
  depth	 = hslider("depth", 1, 0, 1, 0.001);
  fb	 = hslider("feedback gain", 0, 0, 1, 0.001);
  invert   = checkbox("invert");
  level	 = hslider("level [unit:dB]", 0, -60, 10, 0.1) : db2linear;
  curdel1 = odflange+dflange*(1 + lfol(freq))/2; 
  curdel2 = odflange+dflange*(1 + lfor(freq))/2; 
};

//------------------------- stereowidth(w) ---------------------------
// Stereo Width effect using the Blumlein Shuffler technique.
//
// USAGE: "_,_ : stereowidth(w) : _,_", where
//   w = stereo width between 0 and 1
//
// At w=0, the output signal is mono ((left+right)/2 in both channels).
// At w=1, there is no effect (original stereo image).
// Thus, w between 0 and 1 varies stereo width from 0 to "original".
//
// Reference:
// "Applications of Blumlein Shuffling to Stereo Microphone Techniques"
// Michael A. Gerzon, JAES vol. 42, no. 6, June 1994
// 
stereowidth(w) = shuffle : *(mgain),*(sgain) : shuffle
with {
     shuffle =  _,_ <: +,-; // normally scaled by 1/sqrt(2) for orthonormality,
     mgain = 1-w/2;  // but we pick up the needed normalization here.
     sgain = w/2;
};

//--------------------------- ampfollower ---------------------------
// Classic analog audio envelope follower with infinitely fast rise and
// exponential decay.  The amplitude envelope instantaneously follows 
// the absolute value going up, but then floats down exponentially.
//
// USAGE: 
//    _ : ampfollower(rel) : _
//
// where
//  rel = release time = amplitude-envelope time-constant (sec) going down
//
ampfollower(rel) = abs : env with {
 p = tau2pole(rel);
 env(x) = x * (1.0 - p) : + ~ max(x,_) * p;
};

//--------------------------- ampfollower2 ---------------------------
// Envelope follower with different up and down time-constants
//
// USAGE: 
//    _ : ampfollower2(att,rel) : _
//
// where
//  att = attack time = amplitude-envelope time constant (sec) going up
//  rel = release time = amplitude-envelope time constant (sec) going down
//
// For audio, att should be faster (smaller) than rel (e.g., 0.001 and 0.01)

ampfollower2(att,rel) = ampfollower(rel) : smooth(tau2pole(att));

//----------------- compressormono, compressorstereo -------------------
// Mono and stereo dynamic range compressors
//
// USAGE: 
//    _ : compressormono(ratio,thresh,att,rel)   : _
// or
//  _,_ : compressorstereo(ratio,thresh,att,rel) : _,_
//
// where
//  ratio  = compression ratio (1 = no compression, >1 means "ratio to 1 compression")
//  thresh = dB level threshold above which compression kicks in
//  att    = attack time = compression adaptation time constant (sec) when level going up
//  rel    = release time = compression-gain time constant (sec) when level going down
//
// References: 
// - http://en.wikipedia.org/wiki/Dynamic_range_compression
// - https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html
// - Albert Graef's <faust2pd>/examples/synth/compressor.dsp
// 

compressormono(ratio,thresh,att,rel,x) = x * compressiongainmono(ratio,thresh,att,rel,x);

compressorstereo(ratio,thresh,att,rel,x,y) = cgm*x, cgm*y with {
  cgm = compressiongainmono(ratio,thresh,att,rel,abs(x)+abs(y));
};

compressiongainmono(ratio,thresh,att,rel) = 
  ampfollower2(att,rel) : linear2db : outminusindb(ratio,thresh) : kneesmooth(att) : db2linear 
with {
  // Note that kneesmooth(att) installs a "knee" in the dynamic-range compression,
  // where knee smoothness is set equal to half that of the compression-attack.
  // A general 'knee' parameter could be used instead of tying it to att/2:
  kneesmooth(att)  = smooth(tau2pole(att/2.0));
  // compression gain in dB:
   outminusindb(ratio,thresh,level) = max(level-thresh,0) * (1/float(ratio)-1);
  // Note: "float(ratio)" REQUIRED when ratio is an integer > 1!
};

