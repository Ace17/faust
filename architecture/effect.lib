declare name "Faust Audio Effect Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.30";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "https://ccrma.stanford.edu/realsimple/faust_strings/";

import("filter.lib"); // dcblocker*, lowpass, ...

// The following utilities (or equivalents) probably belong in music.lib:
//----------------------- midikey2hz,pianokey2hz ------------------------
midikey2hz(x) = 440.0*pow(2.0, (x-69.0)/12); // MIDI key 69 = A440
pianokey2hz(x) = 440.0*pow(2.0, (x-49.0)/12); // piano key 49 = A440
//---------------------- cross2, bypass1, bypass2 ----------------------
cross2 = _,_,_,_ <: _,!,_,!,!,_,!,_;
bypass1(bpc,e) = _ <: select2(bpc,inswitch:e,_) 
                 with {inswitch = select2(bpc,_,0);};
bypass2(bpc,e) = _,_ <: ((inswitch:e),_,_) : select2stereo(bpc) with {
  inswitch = _,_ : select2(bpc,_,0), select2(bpc,_,0) : _,_;
  select2stereo(bpc) = _,_,_,_ : cross2 : select2(bpc), select2(bpc) : _,_;
};

//--------------- levelfilter, levelfilterN -----------------------
// Dynamic level lowpass filter:
//
// USAGE: levelfilter(L,freq), where
//  L    = desired level (in dB) at Nyquist limit (SR/2), e.g., -60
//  freq = corner frequency (-3dB point) usually set to fundamental freq
//
// REFERENCE: 
// https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html
//
levelfilter(L,freq,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = PI*freq/SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};

levelfilterN(N,freq,L) = seq(i,N,levelfilter((L/N),freq));

//------------------------- speakerbp -------------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to 
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a 
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
// speakerbp(130,5000);
//
// Requires filter.lib
//
speakerbp(f1,f2) = dcblockerat(f1) : dcblockerat(f1) : lowpass(4,f2);


//--------------------- cubicnl(drive,offset) -----------------------
// Cubic nonlinearity distortion
//
// USAGE: cubicnl(drive,offset), where
//   drive  = distortion amount, between 0 and 1
//   offset = constant added before nonlinearity to give even harmonics
//            Note: offset can introduce a nonzero mean - feed
//            cubicnl output to dcblocker to remove this.
//
// REFERENCES:
//   https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html
//   https://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html
//
cubicnl(drive,offset) = *(pregain) : +(offset) : clip(-1,1) : cubic
with {
    pregain = pow(10.0,2*drive);
    clip(lo,hi) = min(hi) : max(lo);
    cubic(x) = x - x*x*x/3;
    postgain = max(1.0,1.0/pregain); // unity gain when nearly linear
};

cubicnl_nodc(drive,offset) = cubicnl(drive,offset) : dcblocker;

//--------------------------- cubicnl_demo --------------------------
// USAGE: _ : cubicnl_demo : _;
//
cubicnl_demo = bypass1(bp, 
   cubicnl_nodc(drive:smooth(0.999),offset:smooth(0.999))) 
with {
   cnl_group(x)  = vgroup("CUBIC NONLINEARITY cubicnl 
        [tooltip: Reference: 
         https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html]", x);
//   bypass_group(x) = cnl_group(hgroup("[0]", x));
   slider_group(x)  = cnl_group(hgroup("[1]", x));
//   bp = bypass_group(checkbox("[0] Bypass  
   bp = slider_group(checkbox("[0] Bypass  
        [tooltip: When this is checked, the nonlinearity has no effect]"));
//   drive = slider_group(vslider("[1] Drive [style: knob] 
   drive = slider_group(hslider("[1] Drive
                       [tooltip: Amount of distortion]", 
                       0, 0, 1, 0.01));
//   offset = slider_group(vslider("[2] Offset [style: knob] 
   offset = slider_group(hslider("[2] Offset
                       [tooltip: Brings in even harmonics]", 
                       0, 0, 1, 0.01));
};

//------------------------- moog_vcf(res,fr) ---------------------------
// Moog "Voltage Controlled Filter" (VCF)
//
// USAGE: moog_vcf(res,fr), where
//   fr = corner-resonance frequency in Hz ( less than SR/6.3 or so )
//   res  = Normalized amount of corner-resonance between 0 and 1 
//        (0 is no resonance, 1 is infinite Q)
// Requires filter.lib.
//
// REFERENCES:
//  https://ccrma.stanford.edu/~stilti/papers/moogvcf.pdf
//  https://ccrma.stanford.edu/~jos/pasp/vegf.html
// 
moog_vcf(res,fr) = (+ : seq(i,4,pole(p)) : *(unitygain(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * PI / SR; // good approximation for fr << SR
     unitygain(p) = pow(1.0-p,4.0); // one-pole unity-gain scaling
     mk = 0-4.0*max(0,min(res,0.999999)); // need mk > -4 for stability
};

//------------------------- moog_vcf_demo ---------------------------
// USAGE: _ : moog_vcf_demo : _;

moog_vcf_demo = bypass1(bp,vcf) with {
   mvcf_group(x)  = hgroup("MOOG VCF (Voltage Controlled Filter)  
      [tooltip: See Faust's filter.lib for info and references]",x);

   meter_group(x) = mvcf_group(vgroup("[0]",x));

   bp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked, the Moog VCF has no effect]"));

   freq = mvcf_group(hslider("[1] Corner Frequency [unit:PK] [style:knob] 
	  [tooltip: The VCF resonates at the corner frequency (specified in
	   PianoKey (PK) units, with A440 = 49 PK).  The VCF response is flat
	   below the corner frequency, and rolls off -24 dB per octave above.]",
          25, 1, 88, 0.01) : pianokey2hz);

   res = mvcf_group(hslider("[2] Corner Resonance [style:knob] 
         [tooltip: Amount of resonance near VCF corner frequency 
         (specified between 0 and 1)]", 
         0.9, 0, 1, 0.01));

   outgain  = meter_group(hslider("[1] VCF Output Level [unit:dB] 
              [tooltip: output level in decibels]",
              5, -60, 20, 0.1)) : component("music.lib").db2linear;

   vcf = outgain * moog_vcf(res,freq:smooth(0.99));

};

//-------------------------- wah4(fr) -------------------------------
// Wah effect, 4th order
// USAGE: wah4(fr), where fr = resonance frequency in Hz
// REFERENCE "https://ccrma.stanford.edu/~jos/pasp/vegf.html";
// 
wah4(fr) = 4*moog_vcf((3.2/4),fr:smooth(0.999));

//------------------------- wah4_demo ---------------------------
// USAGE: _ : wah4_demo : _;

wah4_demo = bypass1(bp, wah4(fr)) with {
  wah4_group(x)  = hgroup("WAH4 
       [tooltip: Fourth-order wah effect made using moog_vcf]", x);
  bp = wah4_group(checkbox("[0] Bypass 
       [tooltip: When this is checked, the wah pedal has no effect]"));
  fr = wah4_group(hslider("[1] Resonance Frequency 
       [tooltip: wah resonance frequency in Hz]",
     200,100,2000,1)); 
// Avoid dc with the moog_vcf (amplitude too high when freq comes up from dc)
// Also, avoid very high resonance frequencies (e.g., 5kHz or above).
};

//------------------------ crybaby(wah) -----------------------------
// Digitized CryBaby wah pedal
// USAGE: _ : crybaby(wah) : _;
// where wah = "pedal angle" from 0 to 1.
// REFERENCE: https://ccrma.stanford.edu/~jos/pasp/vegf.html
//
crybaby(wah) = *(gs) : tf2(1,-1,0,a1s,a2s)
with {
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/SR; // Normalized pole frequency (cycles per sample)
  R = 1 - PI*frn/Q; // pole radius
  theta = 2*PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  s = 0.999; // smoothing parameter (one-pole pole location)
  a1s = a1 : smooth(s);
  a2s = a2 : smooth(s);
  gs =  g  : smooth(s);

  tf2 = component("filter.lib").tf2;
};

//------------------------- crybaby_demo ---------------------------
// USAGE: _ : crybaby_demo : _ ;

crybaby_demo = bypass1(bp, crybaby(wah)) with {
   crybaby_group(x)  = hgroup("CRYBABY [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/vegf.html]", x);
   bp = crybaby_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah pedal has no effect]"));
   wah = crybaby_group(hslider("[1] Wah [tooltip: wah pedal angle between 0 (rocked back) and 1 (rocked forward)]",0.8,0,1,0.01));
};

//------------ piano_dispersion_filter(M,B,f0) ---------------
// Piano dispersion allpass filter in closed form 
//
// ARGUMENTS:
//   M = number of first-order allpass sections (compile-time only)
//       Keep below 20. 8 is typical for medium-sized piano strings.
//   B = string inharmonicity coefficient (0.0001 is typical)
//  f0 = fundamental frequency in Hz
//
// INPUT:
//   Signal to be filtered by the allpass chain
//
// OUTPUTS:
//  1. MINUS the estimated delay at f0 of allpass chain in samples,
//     provided in negative form to facilitate subtraction
//     from delay-line length (see USAGE below).
//  2. Output signal from allpass chain
//
// USAGE:
//  piano_dispersion_filter(1,B,f0) : +(totalDelay),_ : fdelay(maxDelay)
//
// REFERENCE: 
//   "Dispersion Modeling in Waveguide Piano Synthesis
//    Using Tunable Allpass Filters",
//   by Jukka Rauhala and Vesa Valimaki, DAFX-2006, pp. 71-76
//   URL: http://www.dafx.ca/proceedings/papers/p_071.pdf
//   NOTE: An erratum in Eq. (7) is corrected in Dr. Rauhala's 
//    encompassing dissertation (and below).
//   See also: http://www.acoustics.hut.fi/research/asp/piano/
//
piano_dispersion_filter(M,B,f0) = -Df0*M,seq(i,M,tf1(a1,1,a1))
with {
 a1 = (1-D)/(1+D); // By Eq. 3, have D >= 0, hence a1 >= 0 also
 D = exp(Cd - Ikey(f0)*kd); 
 trt = pow(2.0,1.0/12.0); // 12th root of 2
 logb(b,x) = log(x) / log(b); // log-base-b of x
 Ikey(f0) = logb(trt,f0*trt/27.5);
 Bc = max(B,0.000001);
 kd = exp(k1*log(Bc)*log(Bc) + k2*log(Bc)+k3);
 Cd = exp((m1*log(M)+m2)*log(Bc)+m3*log(M)+m4);
 k1 = -0.00179;
 k2 = -0.0233;
 k3 = -2.93;
 m1 = 0.0126;
 m2 = 0.0606;
 m3 = -0.00825;
 m4 = 1.97;
 wT = 2*PI*f0/SR;
 polydel(a) = atan(sin(wT)/(a+cos(wT)))/wT;
 Df0 = polydel(a1) - polydel(1.0/a1);
};

//------- flanger_mono, flanger_stereo, flanger_demo -------
// Flanging effect
//
// USAGE:
//     _ : flanger_mono(dmax,curdel,depth,fb,invert) : _;
//   _,_ : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert) : _,_;
//   _,_ : flanger_demo : _,_;
//
// ARGUMENTS:
//   dmax   = maximum delay-line length (power of 2) - 10 ms typical
//   curdel = current dynamic delay (not to exceed dmax)
//   depth  = effect strength between 0 and 1 (1 typical)
//   fb     = feedback gain between 0 and 1 (0 typical)
//   invert = 0 for normal, 1 to invert sign of flanging sum
//
// REFERENCE: 
//    https://ccrma.stanford.edu/~jos/pasp/Flanging.html
//
flanger_mono(dmax,curdel,depth,fb,invert)
  = _ <: _, (-:fdelay(dmax,curdel)) ~ *(fb) : _, 
  *(select2(invert,depth,0-depth)) 
  : + : *(0.5);

flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert)
  =  flanger_mono(dmax,curdel1,depth,fb,invert),
     flanger_mono(dmax,curdel2,depth,fb,invert);

//------------------------- flanger_demo ---------------------------
// USAGE:  _,_ : flanger_demo : _,_;
//
flanger_demo = bypass2(fbp,flanger_stereo_demo) with {
   flanger_group(x) = 
    vgroup("FLANGER [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
   meter_group(x) = flanger_group(hgroup("[0]", x));
   ctl_group(x)  = flanger_group(hgroup("[1]", x));
   del_group(x)  = flanger_group(hgroup("[2] Delay Controls", x));
   lvl_group(x)  = flanger_group(hgroup("[3]", x));

   fbp = meter_group(checkbox(
         "[0] Bypass  [tooltip: When this is checked, the flanger has no effect]"));
   invert = meter_group(checkbox("[1] Invert Flange Sum"));

   // FIXME: This should be an amplitude-response display:
   flangeview = lfor(freq) + lfol(freq) : meter_group(hbargraph(
      "[2] Flange LFO [style: led] [tooltip: Display sum of flange delays]", -1.5,+1.5));

   flanger_stereo_demo(x,y) = attach(x,flangeview),y : 
     *(level),*(level) : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert);

   lfol = component("osc.lib").oscrs; // sine for left channel
   lfor = component("osc.lib").oscrc; // cosine for right channel
   dmax = 2048;
   dflange = 0.001 * SR * 
     del_group(hslider("[1] Flange Delay [unit:ms] [style:knob]", 10, 0, 20, 0.001));
   odflange = 0.001 * SR * 
     del_group(hslider("[2] Delay Offset [unit:ms] [style:knob]", 1, 0, 20, 0.001));
   freq   = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.01));
   depth  = ctl_group(hslider("[2] Depth [style:knob]", 1, 0, 1, 0.001));
   fb     = ctl_group(hslider("[3] Feedback [style:knob]", 0, -0.999, 0.999, 0.001));
   level  = lvl_group(hslider("Flanger Output Level [unit:dB]", 0, -60, 10, 0.1)) : db2linear;
   curdel1 = odflange+dflange*(1 + lfol(freq))/2; 
   curdel2 = odflange+dflange*(1 + lfor(freq))/2; 
};

//------- phaser2_mono, phaser2_stereo, phaser2_demo -------
// Phasing effect
//
// USAGE:
//   _ : phaser2_mono(Notches,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _;
// _,_ : phaser2_stereo(") : _,_;
// _,_ : phaser2_demo : _,_;
//
// ARGUMENTS:
//   Notches = number of spectral notches (MACRO ARGUMENT - not a signal)
//   width  = approximate width of spectral notches in Hz
//   frqmin = approximate minimum frequency of first spectral notch in Hz
//   fratio = ratio of adjacent notch frequencies
//   frqmax = approximate maximum frequency of first spectral notch in Hz
//   speed  = LFO frequency in Hz (rate of periodic notch sweep cycles)
//   depth  = effect strength between 0 and 1 (1 typical) (aka "intensity")
//            when depth=2, "vibrato mode" is obtained (pure allpass chain)
//   fb     = feedback gain between -1 and 1 (0 typical)
//   invert = 0 for normal, 1 to invert sign of flanging sum
//
// REFERENCES:
//    https://ccrma.stanford.edu/~jos/pasp/Phasing.html
//    http://www.geofex.com/Article_Folders/phasers/phase.html
//    'An Allpass Approach to Digital Phasing and Flanging', Julius O. Smith III, 
//    Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.
//    CCRMA Tech. Report STAN-M-21: https://ccrma.stanford.edu/STANM/stanms/stanm21/

vibrato2_mono(sections,phase01,fb,width,frqmin,fratio,frqmax,speed) = 
 (+ : seq(i,sections,ap2p(R,th(i)))) ~ *(fb)
with {
     tf2 = component("filter.lib").tf2;
     // second-order resonant digital allpass given pole radius and angle:
     ap2p(R,th) = tf2(a2,a1,1,a1,a2) with {
       a2 = R^2;
       a1 = -2*R*cos(th);
     };
     SR = component("music.lib").SR;
     R = exp(-pi*width/SR);
     cososc = component("osc.lib").oscrc;
     sinosc = component("osc.lib").oscrs;
     osc = cososc(speed) * phase01 + sinosc(speed) * (1-phase01);
     lfo = (1-osc)/2; // in [0,1]
     pi = 4*atan(1);
     thmin = 2*pi*frqmin/SR;
     thmax = 2*pi*frqmax/SR;
     th1 = thmin + (thmax-thmin)*lfo;
     th(i) = (fratio^(i+1))*th1;
};

phaser2_mono(Notches,phase01,width,frqmin,fratio,frqmax,speed,depth,fb,invert) = 
      _ <: *(g1) + g2mi*vibrato2_mono(Notches,phase01,fb,width,frqmin,fratio,frqmax,speed)
with {               // depth=0 => direct-signal only
     g1 = 1-depth/2; // depth=1 => phaser mode (equal sum of direct and allpass-chain)
     g2 = depth/2;   // depth=2 => vibrato mode (allpass-chain signal only)
     g2mi = select2(invert,g2,-g2); // inversion negates the allpass-chain signal
};

phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,depth,fb,invert)
   = phaser2_mono(Notches,0,width,frqmin,fratio,frqmax,speed,depth,fb,invert),
     phaser2_mono(Notches,1,width,frqmin,fratio,frqmax,speed,depth,fb,invert);

//------------------------- phaser2_demo ---------------------------
// USAGE:  _,_ : phaser2_demo : _,_;
//
phaser2_demo = bypass2(pbp,phaser2_stereo_demo) with {
   phaser2_group(x) = 
    vgroup("PHASER2 [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
   meter_group(x) = phaser2_group(hgroup("[0]", x));
   ctl_group(x)  = phaser2_group(hgroup("[1]", x));
   nch_group(x)  = phaser2_group(hgroup("[2]", x));
   lvl_group(x)  = phaser2_group(hgroup("[3]", x));

   pbp = meter_group(checkbox(
         "[0] Bypass  [tooltip: When this is checked, the phaser has no effect]"));
   invert = meter_group(checkbox("[1] Invert Internal Phaser Sum"));
   vibr   = meter_group(checkbox("[2] Vibrato Mode")); // In this mode you can hear any "Doppler"

   // FIXME: This should be an amplitude-response display:
   //flangeview = phaser2_amp_resp : meter_group(hspectrumview("[2] Phaser Amplitude Response", 0,1));
   //phaser2_stereo_demo(x,y) = attach(x,flangeview),y : ...

   phaser2_stereo_demo = *(level),*(level) : 
     phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert);

   Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes

   // FIXME: Add tooltips
   speed  = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.001));
   depth  = ctl_group(hslider("[2] Notch Depth (Intensity) [style:knob]", 1, 0, 1, 0.001));
   fb     = ctl_group(hslider("[3] Feedback Gain [style:knob]", 0, -0.999, 0.999, 0.001));

   width  = nch_group(hslider("[1] Notch width [unit:Hz] [style:knob]", 1000, 10, 5000, 1));
   frqmin = nch_group(hslider("[2] Min Notch1 Freq [unit:Hz] [style:knob]", 100, 20, 5000, 1));
   frqmax = nch_group(hslider("[3] Max Notch1 Freq [unit:Hz] [style:knob]", 800, 20, 10000, 1)) : max(frqmin);
   fratio = nch_group(hslider("[4] Notch Freq Ratio: NotchFreq(n+1)/NotchFreq(n)  [style:knob]", 1.5, 1.1, 4, 0.001));

   level  = lvl_group(hslider("Phaser Output Level [unit:dB]", 0, -60, 10, 0.1)) : component("music.lib").db2linear;

   mdepth = select2(vibr,depth,2); // Improve "ease of use"
};

//------------------------- stereo_width(w) ---------------------------
// Stereo Width effect using the Blumlein Shuffler technique.
//
// USAGE: "_,_ : stereo_width(w) : _,_", where
//   w = stereo width between 0 and 1
//
// At w=0, the output signal is mono ((left+right)/2 in both channels).
// At w=1, there is no effect (original stereo image).
// Thus, w between 0 and 1 varies stereo width from 0 to "original".
//
// REFERENCE:
// "Applications of Blumlein Shuffling to Stereo Microphone Techniques"
// Michael A. Gerzon, JAES vol. 42, no. 6, June 1994
// 
stereo_width(w) = shuffle : *(mgain),*(sgain) : shuffle
with {
     shuffle =  _,_ <: +,-; // normally scaled by 1/sqrt(2) for orthonormality,
     mgain = 1-w/2;  // but we pick up the needed normalization here.
     sgain = w/2;
};

//--------------------------- amp_follower ---------------------------
// Classic analog audio envelope follower with infinitely fast rise and
// exponential decay.  The amplitude envelope instantaneously follows 
// the absolute value going up, but then floats down exponentially.
//
// USAGE: 
//    _ : amp_follower(rel) : _
//
// where
//  rel = release time = amplitude-envelope time-constant (sec) going down
//
// REFERENCES:
//  Musical Engineer's Handbook, Bernie Hutchins, Ithaca NY, 1975
//  Elecronotes Newsletter, Bernie Hutchins

amp_follower(rel) = abs : env with {
 p = tau2pole(rel);
 env(x) = x * (1.0 - p) : + ~ max(x,_) * p;
};

//--------------------------- amp_follower_ud ---------------------------
// Envelope follower with different up and down time-constants
//
// USAGE: 
//    _ : amp_follower_ud(att,rel) : _
//
// where
//  att = attack time = amplitude-envelope time constant (sec) going up
//  rel = release time = amplitude-envelope time constant (sec) going down
//
// For audio, att should be faster (smaller) than rel (e.g., 0.001 and 0.01)

amp_follower_ud(att,rel) = amp_follower(rel) : smooth(tau2pole(att));

//----------------- gate_mono, gate_stereo -------------------
// Mono and stereo signal gates
//
// USAGE: 
//    _ : gate_mono(thresh,att,hold,rel)   : _
// or
//  _,_ : gate_stereo(thresh,att,hold,rel) : _,_
//
// where
//  thresh = dB level threshold above which gate opens (e.g., -60 dB)
//  att    = attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)
//  hold   = hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)
//  rel    = release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)
//
// REFERENCES: 
// - http://en.wikipedia.org/wiki/Noise_gate
// - http://www.soundonsound.com/sos/apr01/articles/advanced.asp
// - http://en.wikipedia.org/wiki/Gating_(sound_engineering)

gate_mono(thresh,att,hold,rel,x) = x * gate_gain_mono(thresh,att,hold,rel,x);

gate_stereo(thresh,att,hold,rel,x,y) = ggm*x, ggm*y with {
  ggm = gate_gain_mono(thresh,att,hold,rel,abs(x)+abs(y));
};

gate_gain_mono(thresh,att,hold,rel,x) = extendedrawgate : amp_follower_ud(att,rel) with {
  extendedrawgate = max(rawgatesig,holdsig);
  rawgatesig = inlevel(x) > db2linear(thresh);
  inlevel(x) = amp_follower_ud(att/2,rel/2,x);
  holdsig = ((max(holdreset & holdsamps,_) ~-(1)) > 0);
  holdreset = rawgatesig > rawgatesig'; // reset hold when raw gate falls
  holdsamps = int(hold*SR);
};

//-------------------- compressor_mono, compressor_stereo ----------------------
// Mono and stereo dynamic range compressor_s
//
// USAGE: 
//    _ : compressor_mono(ratio,thresh,att,rel)   : _
// or
//  _,_ : compressor_stereo(ratio,thresh,att,rel) : _,_
//
// where
//  ratio  = compression ratio (1 = no compression, >1 means compression")
//  thresh = dB level threshold above which compression kicks in
//  att    = attack time = time constant (sec) when level & compression going up
//  rel    = release time = time constant (sec) coming out of compression 
//
// REFERENCES: 
// - http://en.wikipedia.org/wiki/Dynamic_range_compression
// - https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html
// - Albert Graef's <faust2pd>/examples/synth/compressor_.dsp
// 

compressor_mono(ratio,thresh,att,rel,x) = x * compression_gain_mono(ratio,thresh,att,rel,x);

compressor_stereo(ratio,thresh,att,rel,x,y) = cgm*x, cgm*y with {
  cgm = compression_gain_mono(ratio,thresh,att,rel,abs(x)+abs(y));
};

compression_gain_mono(ratio,thresh,att,rel) = 
  amp_follower_ud(att,rel) : linear2db : outminusindb(ratio,thresh) : 
  kneesmooth(att) : db2linear 
with {
  // kneesmooth(att) installs a "knee" in the dynamic-range compression,
  // where knee smoothness is set equal to half that of the compression-attack.
  // A general 'knee' parameter could be used instead of tying it to att/2:
  kneesmooth(att)  = smooth(tau2pole(att/2.0));
  // compression gain in dB:
   outminusindb(ratio,thresh,level) = max(level-thresh,0) * (1/float(ratio)-1);
  // Note: "float(ratio)" REQUIRED when ratio is an integer > 1!
};

//---------------------------- gate_demo -------------------------
// USAGE: _,_ : gate_demo : _,_;
//
gate_demo = bypass2(gbp,gate_stereo_demo) with {

   gate_group(x)  = vgroup("GATE  [tooltip: Reference: http://en.wikipedia.org/wiki/Noise_gate]", x);
   meter_group(x) = gate_group(hgroup("[0]", x));
   knob_group(x)  = gate_group(hgroup("[1]", x));

   gbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked, the gate has no effect]"));

   gateview = gate_gain_mono(gatethr,gateatt,gatehold,gaterel) : linear2db :
     meter_group(hbargraph("[1] Gate Gain [unit:dB]  [tooltip: Current gain of the gate in dB]",
      -50,+10)); // [style:led]

   gate_stereo_demo(x,y) = attach(x,gateview(abs(x)+abs(y))),y : 
     gate_stereo(gatethr,gateatt,gatehold,gaterel);

   gatethr = knob_group(hslider("[1] Threshold [unit:dB] [style:knob]  [tooltip: When the signal level falls below the Threshold (expressed in dB), the signal is muted]", 
     -30, -120, 0, 0.1));

   gateatt = knob_group(hslider("[2] Attack [unit:us] [style:knob]  [tooltip: Time constant in MICROseconds (1/e smoothing time) for the gate gain to go (exponentially) from 0 (muted) to 1 (unmuted)]",
     10, 10, 10000, 1)) : *(0.000001) : max(1/SR);

   gatehold = knob_group(hslider("[3] Hold [unit:ms] [style:knob]  [tooltip: Time in ms to keep the gate open (no muting) after the signal level falls below the Threshold]",
     200, 0, 1000, 1)) : *(0.001) : max(1/SR);

   gaterel = knob_group(hslider("[4] Release [unit:ms] [style:knob]  [tooltip: Time constant in ms (1/e smoothing time) for the gain to go (exponentially) from 1 (unmuted) to 0 (muted)]", 
     100, 0, 1000, 1)) : *(0.001) : max(1/SR);
};

//---------------------------- compressor_demo -------------------------
// USAGE: _,_ : compressor_demo : _,_;
//
compressor_demo = bypass2(cbp,compressor_stereo_demo) with {

   comp_group(x) = vgroup("COMPRESSOR  [tooltip: Reference: http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

   meter_group(x)  = comp_group(hgroup("[0]", x));
   knob_group(x)  = comp_group(hgroup("[1]", x));

   cbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked, the compressor has no effect]"));

   gainview = 
     compression_gain_mono(ratio,threshold,attack,release) : linear2db : 
     meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain of the compressor in dB]",
      -50,+10));

   displaygain = _,_ <: _,_,(abs,abs:+) : _,_,gainview : _,attach;

   compressor_stereo_demo = 
     displaygain(compressor_stereo(ratio,threshold,attack,release)) : 
     *(makeupgain), *(makeupgain);

   ctl_group(x)  = knob_group(hgroup("[3] Compression Control", x));

   ratio = ctl_group(hslider("[0] Ratio [style:knob]  [tooltip: A compression Ratio of N means that for each N dB increase in input signal level above Threshold, the output level goes up 1 dB]", 
     5, 1, 20, 0.1));

   threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob]  [tooltip: When the signal level exceeds the Threshold (in dB), its level is compressed according to the Ratio]",
     -30, -100, 10, 0.1));

   env_group(x)  = knob_group(hgroup("[4] Compression Response", x));

   attack = env_group(hslider("[1] Attack [unit:ms] [style:knob]  [tooltip: Time constant in ms (1/e smoothing time) for the compression gain to approach (exponentially) a new lower target level (the compression `kicking in')]",
     50, 0, 500, 0.1)) : *(0.001) : max(1/SR);

   release = env_group(hslider("[2] Release [unit:ms] [style: knob]  [tooltip: Time constant in ms (1/e smoothing time) for the compression gain to approach (exponentially) a new higher target level (the compression 'releasing')]",
     500, 0, 1000, 0.1)) : *(0.001) : max(1/SR);

   makeupgain = comp_group(hslider("[5] Makeup Gain [unit:dB]  [tooltip: The compressed-signal output level is increased by this amount (in dB) to make up for the level lost due to compression]",
     40, -96, 96, 0.1)) : db2linear;
};

//------------------------------- limiter_* ------------------------------------
// USAGE: 
//     _ : limiter_1176_R4_mono   : _;
//   _,_ : limiter_1176_R4_stereo : _,_;
//
// DESCRIPTION:
//   A limiter guards against hard-clipping.  It can be can be
//   implemented as a compressor having a high threshold (near the
//   clipping level), fast attack and release, and high ratio.  Since
//   the ratio is so high, some knee smoothing is
//   desirable ("soft limiting").  This example is intended
//   to get you started using compressor_* as a limiter, so all
//   parameters are hardwired to nominal values here.
//
// REFERENCE: http://en.wikipedia.org/wiki/1176_Peak_Limiter
//   Ratios: 4 (moderate compression), 8 (severe compression), 
//          12 (mild limiting), or 20 to 1 (hard limiting)
//   Att: 20-800 MICROseconds (Note: scaled by ratio in the 1176)
//   Rel: 50-1100 ms (Note: scaled by ratio in the 1176)
//   Mike Shipley likes 4:1 (Grammy-winning mixer for Queen, Tom Petty, etc.) 
//     Faster attack gives "more bite" (e.g. on vocals)
//     He hears a bright, clear eq effect as well (not implemented here)
//
limiter_1176_R4_mono = compressor_mono(4,-6,0.0008,0.5);
limiter_1176_R4_stereo = compressor_stereo(4,-6,0.0008,0.5);

//------------------------------ jcrev,brassrev ------------------------------
// USAGE: 
//     _ :    jcrev : _,_,_,_
//     _ : brassrev : _,_
//
// DESCRIPTION:
//   These artificial reverberators take a mono signal and output stereo
//   (brassrev) and quad (jcrev).  They were implemented by John Chowning
//   in the MUS10 computer-music language (descended from Music V by Max
//   Mathews).  They are Schroeder Reverberators, well tuned for their size.

// This reverberator, from a SAIL DART tape, dated April 14, 1972, is a listing
// of RV, a reverberator that John Chowning thinks might have become JCREV:

jcrev = _ : allpass_chain <: comb_bank :> _ <: mix_mtx with {

  rev1N = component("filter.lib").rev1;

  rev12(len,g) = rev1N(2048,len,g);
  rev14(len,g) = rev1N(4096,len,g);

  allpass_chain = 
    rev2(512,347,0.7) : 
    rev2(128,113,0.7) : 
    rev2( 64, 37,0.7);

  comb_bank = 
    rev12(1601,.802),
    rev12(1867,.773),
    rev14(2053,.753),
    rev14(2251,.733);

  mix_mtx = _,_,_,_ <: psum, (psum:*(-1)),asum,(asum:*(-1)) with {
    psum = _,_,_,_ :> _;
    asum = *(-1),_,*(-1),_ :> _;
  };
};

// This reverberator, from a SAIL DART tape, dated May 15, 1971, is a listing
// of SATREV, a reverberator that John Chowning thinks might have been used
// for his often-heard brass canon sound examples, one of which can be found at
// https://ccrma.stanford.edu/~jos/wav/FM_BrassCanon2.wav

brassrev = _ <: comb_bank :> allpass_chain <: _,*(-1) with {

  rev1N = component("filter.lib").rev1;

  rev11(len,g) = rev1N(1024,len,g);
  rev12(len,g) = rev1N(2048,len,g);

  comb_bank = 
    rev11( 778,.827),
    rev11( 901,.805),
    rev11(1011,.783),
    rev12(1123,.764);

  rev2N = component("filter.lib").rev2;

  allpass_chain = 
    rev2N(128,125,0.7) : 
    rev2N( 64, 42,0.7) : 
    rev2N( 16, 12,0.7);
};

//------------------------- reverb_demo ---------------------------
// USAGE: _,_ : reverb_demo : _,_ ;

reverb_demo = reverbs with {

//   reverbs = _,_ <: (_,_ :> jcrev :> _,_) , (_,_ :> brassrev) :> _,_;
   reverbs = _,_ <: 
        bypass2(1-ck1, (_,_ :> jcrev :> _,_)),
        bypass2(1-ck2, (_,_ :> brassrev))
   :> _,_;
      
   reverb_group(x)  = vgroup("REVERBS 
     [tooltip: See Faust's effect.lib for documentation and references]", x);

   ck1 = reverb_group(checkbox("[1] JCREV
    [tooltip: When this is checked,  the JCREV reverberator is in effect]"));
   ck2 = reverb_group(checkbox("[2] BRASSREV
    [tooltip: When this is checked,  the BRASSREV reverberator is in effect]"));
};
